"""Pydantic models for AI-related data structures."""

from typing import Any, Literal

from pydantic import BaseModel, ConfigDict, Field, ValidationInfo, field_validator


class PlanAction(BaseModel):
    """Action describing either a command or a code patch."""

    type: Literal["command", "patch"] = Field(description="Action type")
    command: str | None = Field(default=None, description="Shell command to execute")
    user: Literal["sandbox", "root"] | None = Field(
        default=None,
        description="Sandbox user to execute command as",
    )
    path: str | None = Field(default=None, description="File path for patch application")
    language: str | None = Field(default=None, description="Code language for patch context")
    original: str | None = Field(default=None, description="Original snippet to replace")
    replacement: str | None = Field(default=None, description="Replacement snippet")
    explanation: str | None = Field(default=None, description="Brief explanation of the change")

    model_config = ConfigDict(extra="forbid")

    @field_validator("command")
    @classmethod
    def _require_command(cls, value: str | None, info: ValidationInfo) -> str | None:
        if info.data.get("type") != "command":
            return value
        if not value or not value.strip():
            msg = "Command action requires non-empty command"
            raise ValueError(msg)
        return value.strip()

    @field_validator("replacement")
    @classmethod
    def _validate_replacement_length(cls, value: str | None, info: ValidationInfo) -> str | None:
        if info.data.get("type") != "patch":
            return value
        if not value or not value.strip():
            msg = "Patch action requires replacement text"
            raise ValueError(msg)
        line_count = value.count("\n") + 1
        if line_count > 100:
            msg = "Patch replacement must be â‰¤ 100 lines"
            raise ValueError(msg)
        return value

    @field_validator("path", "original")
    @classmethod
    def _require_patch_fields(cls, value: str | None, info: ValidationInfo) -> str | None:
        if info.data.get("type") != "patch":
            return value
        if not value or not value.strip():
            field_name = info.field_name
            msg = f"Patch action requires field '{field_name}'"
            raise ValueError(msg)
        return value

    @field_validator("user")
    @classmethod
    def _default_user(cls, value: str | None, info: ValidationInfo) -> str:
        if info.data.get("type") == "command":
            return value or "sandbox"
        return "sandbox"


class Lesson(BaseModel):
    """Model for a lesson in the course structure."""

    title: str = Field(description="Title of the lesson")
    description: str = Field(description="Brief description of what the lesson covers")
    module: str | None = Field(
        default=None, description="Optional module/section name for grouping"
    )

    model_config = ConfigDict(extra="forbid")


class CourseStructure(BaseModel):
    """Model for the course/roadmap structure returned by AI."""

    title: str
    description: str
    # Required list to satisfy strict schema requirement (no default)
    lessons: list[Lesson]
    setup_commands: list[str] = Field(
        default_factory=list,
        description="Commands to run once per course sandbox (e.g., 'pip install numpy pandas')",
    )

    model_config = ConfigDict(extra="forbid")

    @field_validator("setup_commands", mode="before")
    @classmethod
    def _ensure_setup_commands(cls, value: Any) -> list[str]:
        """Normalize setup_commands to list of strings."""
        if value is None:
            return []
        if isinstance(value, list):
            return [str(item).strip() for item in value if str(item).strip()]
        if isinstance(value, str) and value.strip():
            return [value.strip()]
        return []


class LessonContent(BaseModel):
    """Model for lesson content returned by AI."""

    body: str = Field(description="The full lesson content in Markdown format")

    model_config = ConfigDict(extra="forbid")


class ExecutionFile(BaseModel):
    """File that should be created inside the sandbox before execution."""

    path: str = Field(description="Absolute or relative filesystem path inside the sandbox")
    content: str = Field(description="File contents to write")
    executable: bool = Field(default=False, description="Whether to mark the file as executable")

    model_config = ConfigDict(extra="forbid")


class ExecutionPlan(BaseModel):
    """Structured plan generated by the LLM for sandbox execution."""

    language: str = Field(description="Normalized language identifier (informational)")
    summary: str = Field(description="High-level summary of the plan")
    files: list[ExecutionFile] = Field(default_factory=list, description="Files to materialize inside the sandbox")
    actions: list[PlanAction] = Field(default_factory=list, description="Ordered execution/patch actions")
    setup_commands: list[str] = Field(
        default_factory=list,
        description="Idempotent setup commands (mkdir, chmod, etc.)",
    )
    install_commands: list[str] = Field(
        default_factory=list,
        description="Commands that install system or language packages",
    )
    run_commands: list[str] = Field(
        default_factory=list,
        description="Commands that should be executed to run the user code",
    )
    environment: dict[str, str] = Field(
        default_factory=dict,
        description="Environment variables to set for subsequent commands",
    )

    model_config = ConfigDict(extra="forbid")

    @field_validator("setup_commands", "install_commands", "run_commands", mode="before")
    @classmethod
    def _ensure_list(cls, value: Any) -> list[str]:
        if value is None:
            return []
        if isinstance(value, list):
            return [str(item).strip() for item in value if str(item).strip()]
        if isinstance(value, str) and value.strip():
            return [value.strip()]
        return []

    @field_validator("files", mode="before")
    @classmethod
    def _ensure_files(cls, value: Any) -> list[Any]:
        if value is None:
            return []
        if isinstance(value, list):
            return value
        return [value]

    @field_validator("summary", "language")
    @classmethod
    def _strip_text(cls, value: str) -> str:
        return value.strip()

    @field_validator("setup_commands", "install_commands", "run_commands")
    @classmethod
    def _validate_command_tokens(cls, commands: list[str]) -> list[str]:
        disallowed = {"sudo"}
        sanitized: list[str] = []
        for cmd in commands:
            lower = cmd.lower()
            if any(token in lower.split() for token in disallowed):
                msg = f"Command contains disallowed token: {cmd}"
                raise ValueError(msg)
            sanitized.append(cmd.strip())
        return sanitized

    @field_validator("actions", mode="before")
    @classmethod
    def _ensure_actions(cls, value: Any) -> list[Any]:
        if value is None:
            return []
        if isinstance(value, list):
            return value
        return [value]
